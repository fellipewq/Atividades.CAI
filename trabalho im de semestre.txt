/
#include <Arduino.h>
#include <ezTime.h>
#include <WiFi.h>
#include <WiFiUdp.h>
#include <Wire.h>
#include <NTPClient.h>
#include <VL53L0X.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <WiFiClientSecure.h>
#include "internet.h"
#include "certificados.h"

Timezone tempo;
VL53L0X sensor;
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", -10800, 60000);

const int mqtt_port = 8883;
const char *mqtt_id = "Esp32Fellipe";
const char *mqtt_SUB = "senai134/mesa02";
const char *mqtt_PUB = "senai134/mesa02";

WiFiClientSecure espClient;
PubSubClient mqtt(espClient);
JsonDocument doc;

void ConectaMQTT();
void Callback(char *topic, byte *payload, unsigned int length);

void setup()
{
    Serial.begin(9600);
    Wire.begin();
    conectaWiFi();
    sensor.init();

    // Tenta inicializar o sensor; se falhar, exibe erro no monitor serial
    if (!sensor.init())
    {
        Serial.println("Falha ao detectar e inicializar o sensor!");
        while (1)
        {
        } // Entra em loop infinito se não conseguir iniciar
    }

    sensor.startContinuous();

    espClient.setCACert(AWS_ROOT_CA);
    espClient.setCertificate(AWS_CERT);
    espClient.setPrivateKey(AWS_KEY);

    mqtt.setServer(AWS_BROKER, mqtt_port);
    mqtt.setCallback(Callback);
}

void loop()
{
    checkWiFi();
    timeClient.update();

    if (!mqtt.connected())
    {
        ConectaMQTT();
    }

    mqtt.loop();

    static unsigned long tempo_pub = 0;
    unsigned long agora = millis();

    if (agora - tempo_pub > 2000)
    {
        // Lê a distância em milímetros e imprime na serial
        doc["distancia"] = sensor.readRangeContinuousMillimeters();

        sensor.setTimeout(1000); // Define um tempo limite de 500 ms para leitura do sensor

        // Verifi-ca se houve um timeout (tempo de resposta excedido)
        if (sensor.timeoutOccurred())
        {
            Serial.println(" TIMEOUT"); // Imprime aviso de timeout
        }

        unsigned long epochTime = timeClient.getEpochTime();

        doc["timestamp"] = epochTime;

        String msg;
        serializeJson(doc, msg);
        mqtt.publish(mqtt_PUB, msg.c_str());
        tempo_pub = agora;
    }
    //! mqtt.setCallback (); //CRIAR CALBACK
}

void Callback(char *topic, byte *payload, unsigned int length)
{
    String msg((char *)payload, length);
    Serial.printf("Mensagem recebida (topico: [%s]): %s \n\r", topic, msg.c_str());
}

void ConectaMQTT()
{
    while (!mqtt.connected())
    {
        Serial.println("Conectando ao AWS IoT Core ...");
        if (mqtt.connect(mqtt_id))
        {
            Serial.println("conectado.");
            mqtt.subscribe(mqtt_SUB);
        }
        else
        {
            Serial.printf("Falhou (%d). Tentando novamente em 5s \n\r", mqtt.state());
            delay(5000);
        }
    }
}
//! Codigo do resto do grupo

//! Codigo da Manuela-----------------------------------------------------------------------------------------------
#include <Arduino.h>
#include <LiquidCrystal_I2C.h>
#include <WiFi.h>
#include <WiFiUdp.h>
#include <NTPClient.h>
#include <ezTime.h>
#include "internet.h"     // deve conter void conectaWifi()
#include "certificados.h" // (assumido que é necessário na sua aplicação)
#include <Wire.h>
#include <ArduinoJson.h>
#include <PubSubClient.h>
#include <WiFiClientSecure.h>

WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", -10800, 60000);
WiFiClientSecure espClient;
Timezone tempo;
LiquidCrystal_I2C lcd(0x27, 20, 4);
PubSubClient mqtt(espClient);
JsonDocument doc;
String msg;
String nomeMes;
String nomeDia;

const int mqtt_port = 8883;
const char *mqtt_id = "Esp32Manuelalll";
const char *mqtt_SUB = "senai134/mesa02";
const char *mqtt_PUB = "senai134/mesa02";

void conectaMqtt(void);
void Callback(char *topic, byte *payload, unsigned int lenght);

void setup()
{
  Serial.begin(9600);
  conectaWiFi(); // Sua função definida em "internet.h"

  tempo.setLocation("America/Sao_Paulo");
  waitForSync();

  lcd.init();
  lcd.backlight();
  lcd.setCursor(7, 3);
  lcd.print("SENAI");



  espClient.setCACert(AWS_ROOT_CA);
  espClient.setCertificate(AWS_CERT);
  espClient.setPrivateKey(AWS_KEY);

  mqtt.setServer(AWS_BROKER, mqtt_port);
  mqtt.setCallback(Callback);
}

void loop()
{
  checkWiFi();
  timeClient.update();

  if (!mqtt.connected())
  {
    conectaMqtt();
  }

  unsigned long agora = millis();
  static unsigned long tempo_pub = 0;

  if (agora - tempo_pub > 2000)
  {
    JsonDocument doc;

    unsigned long epochTime = timeClient.getEpochTime();
    doc["timestamp"] = epochTime;

    String msg;
    serializeJson(doc, msg);
    mqtt.publish(mqtt_PUB, msg.c_str());
    tempo_pub = agora;
  }

  switch (tempo.weekday())
  {
  case 1:
    nomeDia = "Domingo";
    break;
  case 2:
    nomeDia = "Segunda-Feira";
    break;
  case 3:
    nomeDia = "Terca-Feira";
    break;
  case 4:
    nomeDia = "Quarta-Feira";
    break;
  case 5:
    nomeDia = "Quinta-Feira";
    break;
  case 6:
    nomeDia = "Sexta-Feira";
    break;
  case 7:
    nomeDia = "Sabado";
    break;
  }

  switch (tempo.month())

  {
  case 1:
    nomeMes = "Janeiro";
    break;

  case 2:
    nomeMes = "Fevereiro";
    break;

  case 3:
    nomeMes = "Março";
    break;

  case 4:
    nomeMes = "Abril";
    break;

  case 5:
    nomeMes = "Maio";
    break;

  case 6:
    nomeMes = "Junho";
    break;

  case 7:
    nomeMes = "Julho";
    break;

  case 8:
    nomeMes = "Agosto";
    break;

  case 9:
    nomeMes = "Setembro";
    break;

  case 10:
    nomeMes = "Outubro";
    break;

  case 11:
    nomeMes = "Novembro";
    break;

  case 12:
    nomeMes = "Dezembro";
    break;
  }

  //*hora
  lcd.setCursor(0, 0);
  lcd.print(tempo.hour());

  //* : para dividir a hora do min
  // lcd.setCursor(2, 0);
  lcd.print(":");

  //*minuto
  // lcd.setCursor(3, 0);
  lcd.print(tempo.minute());

  //* : para dividir o min do seg
  // lcd.setCursor(5, 0);
  lcd.print(":");

  //*segundos
  if (tempo.second() < 10)
  {
    lcd.setCursor(6, 0);
    lcd.print("0");
    lcd.setCursor(7, 0);
    lcd.print(tempo.second());
    lcd.print(" ");
  }
  else
  {
    lcd.setCursor(6, 0);
    lcd.print(tempo.second());
  }

  //*dia da semana escrito
  lcd.setCursor(0, 1);
  lcd.print(nomeDia);

  //*dia
  if (tempo.day() < 10)
  {
    lcd.setCursor(0, 0);
    lcd.print("0");
    lcd.setCursor(1, 1);
    lcd.print(tempo.day());
  }
  else
  {
    lcd.setCursor(0, 2);
    lcd.print(tempo.day());
  }

  //*mes
  lcd.setCursor(2, 2);
  lcd.print(":");
  lcd.setCursor(3, 2);
  lcd.print(nomeMes);
  //*barra para colocar um espaco /
lcd.print(":");

  //*ano
  lcd.setCursor(9, 2);
  lcd.print(tempo.year());

}
void Callback(char *topic, byte *payload, unsigned int lenght)
{
  String msg((char *)payload, lenght);
  Serial.printf("Menesagem recebida (topico: [%s]): %s \n\r", topic, msg.c_str());
}

void conectaMqtt()
{
  while (!mqtt.connected())
  {
    Serial.print("Conectando ao AWS IoT Core.....");

    if (mqtt.connect(mqtt_id))
    {
      Serial.println("CONENCTADO!!!!");
      mqtt.subscribe(mqtt_SUB);
    }

    else
    {
      Serial.printf("Falhou (%d), tentando de novo em 5s", mqtt.state());
      delay(5000);
    }
  }
}

#include <Arduino.h>
#include <LiquidCrystal_I2C.h>
#include <WiFi.h>
#include <WiFiUdp.h>
#include <NTPClient.h>
#include <ezTime.h>
#include "internet.h"     // deve conter void conectaWifi()
#include "certificados.h" // (assumido que é necessário na sua aplicação)
#include <Wire.h>
#include <ArduinoJson.h>
#include <PubSubClient.h>
#include <WiFiClientSecure.h>

WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", -10800, 60000);
WiFiClientSecure espClient;
Timezone tempo;
LiquidCrystal_I2C lcd(0x27, 20, 4);
PubSubClient mqtt(espClient);
JsonDocument doc;
String msg;
String nomeMes;
String nomeDia;

const int mqtt_port = 8883;
const char *mqtt_id = "Esp32Manuelalll";
const char *mqtt_SUB = "senai134/mesa02";
const char *mqtt_PUB = "senai134/mesa02";

void conectaMqtt(void);
void Callback(char *topic, byte *payload, unsigned int lenght);

void setup()
{
  Serial.begin(9600);
  conectaWiFi(); // Sua função definida em "internet.h"

  tempo.setLocation("America/Sao_Paulo");
  waitForSync();

  lcd.init();
  lcd.backlight();
  lcd.setCursor(7, 3);
  lcd.print("SENAI");



  espClient.setCACert(AWS_ROOT_CA);
  espClient.setCertificate(AWS_CERT);
  espClient.setPrivateKey(AWS_KEY);

  mqtt.setServer(AWS_BROKER, mqtt_port);
  mqtt.setCallback(Callback);
}

void loop()
{
  checkWiFi();
  timeClient.update();

  if (!mqtt.connected())
  {
    conectaMqtt();
  }

  unsigned long agora = millis();
  static unsigned long tempo_pub = 0;

  if (agora - tempo_pub > 2000)
  {
    JsonDocument doc;

    unsigned long epochTime = timeClient.getEpochTime();
    doc["timestamp"] = epochTime;

    String msg;
    serializeJson(doc, msg);
    mqtt.publish(mqtt_PUB, msg.c_str());
    tempo_pub = agora;
  }

  switch (tempo.weekday())
  {
  case 1:
    nomeDia = "Domingo";
    break;
  case 2:
    nomeDia = "Segunda-Feira";
    break;
  case 3:
    nomeDia = "Terca-Feira";
    break;
  case 4:
    nomeDia = "Quarta-Feira";
    break;
  case 5:
    nomeDia = "Quinta-Feira";
    break;
  case 6:
    nomeDia = "Sexta-Feira";
    break;
  case 7:
    nomeDia = "Sabado";
    break;
  }

  switch (tempo.month())

  {
  case 1:
    nomeMes = "Janeiro";
    break;

  case 2:
    nomeMes = "Fevereiro";
    break;

  case 3:
    nomeMes = "Março";
    break;

  case 4:
    nomeMes = "Abril";
    break;

  case 5:
    nomeMes = "Maio";
    break;

  case 6:
    nomeMes = "Junho";
    break;

  case 7:
    nomeMes = "Julho";
    break;

  case 8:
    nomeMes = "Agosto";
    break;

  case 9:
    nomeMes = "Setembro";
    break;

  case 10:
    nomeMes = "Outubro";
    break;

  case 11:
    nomeMes = "Novembro";
    break;

  case 12:
    nomeMes = "Dezembro";
    break;
  }

  //*hora
  lcd.setCursor(0, 0);
  lcd.print(tempo.hour());

  //* : para dividir a hora do min
  // lcd.setCursor(2, 0);
  lcd.print(":");

  //*minuto
  // lcd.setCursor(3, 0);
  lcd.print(tempo.minute());

  //* : para dividir o min do seg
  // lcd.setCursor(5, 0);
  lcd.print(":");

  //*segundos
  if (tempo.second() < 10)
  {
    lcd.setCursor(6, 0);
    lcd.print("0");
    lcd.setCursor(7, 0);
    lcd.print(tempo.second());
    lcd.print(" ");
  }
  else
  {
    lcd.setCursor(6, 0);
    lcd.print(tempo.second());
  }

  //*dia da semana escrito
  lcd.setCursor(0, 1);
  lcd.print(nomeDia);

  //*dia
  if (tempo.day() < 10)
  {
    lcd.setCursor(0, 0);
    lcd.print("0");
    lcd.setCursor(1, 1);
    lcd.print(tempo.day());
  }
  else
  {
    lcd.setCursor(0, 2);
    lcd.print(tempo.day());
  }

  //*mes
  lcd.setCursor(2, 2);
  lcd.print(":");
  lcd.setCursor(3, 2);
  lcd.print(nomeMes);
  //*barra para colocar um espaco /
lcd.print(":");

  //*ano
  lcd.setCursor(9, 2);
  lcd.print(tempo.year());

}
void Callback(char *topic, byte *payload, unsigned int lenght)
{
  String msg((char *)payload, lenght);
  Serial.printf("Menesagem recebida (topico: [%s]): %s \n\r", topic, msg.c_str());
}

void conectaMqtt()
{
  while (!mqtt.connected())
  {
    Serial.print("Conectando ao AWS IoT Core.....");

    if (mqtt.connect(mqtt_id))
    {
      Serial.println("CONENCTADO!!!!");
      mqtt.subscribe(mqtt_SUB);
    }

    else
    {
      Serial.printf("Falhou (%d), tentando de novo em 5s", mqtt.state());
      delay(5000);
    }
  }
}

//! Codigo Nycollas---------------------------------------------------------------------------------------------------------------\

#include <Arduino.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <WiFiClientSecure.h>
#include <DHT.h>
#include <ezTime.h>
#include <Adafruit_NeoPixel.h>
#include "internet.h"
#include "certificados.h"

#include <WiFiUdp.h>
#include <NTPClient.h>

//*================MQTT====================
const int mqtt_port = 8883;
const char *mqtt_id = "";
const char *mqtt_SUB = "senai134/mesa02";
const char *mqtt_PUB = "senai134/mesa02";

//*===============LED RGB==================
Adafruit_NeoPixel ledRGB(1, 48, NEO_GBR);
//RGB
int R = 255;
int G = 0;
int B = 0;

//*===============NTP======================
WiFiUDP ntpUDP;
NTPClient timeClient(ntpUDP, "pool.ntp.org", -3 * 3600, 60000);

//*===============Objetos==================
WiFiClientSecure espClient;
PubSubClient mqtt(espClient);
DHT dht(18, DHT22);
JsonDocument doc;
Timezone tempo;

//*===============FUNCOES===================
void conectaMQTT();
void Callback(char *topic, byte *payload, unsigned int length);

void setup()
{
  Serial.begin(9600);
  conectaWiFi();
  dht.begin();
  ledRGB.begin();
  ledRGB.setBrightness(200);

  espClient.setCACert(AWS_ROOT_CA);
  espClient.setCertificate(AWS_CERT);
  espClient.setPrivateKey(AWS_KEY);

  mqtt.setServer(AWS_BROKER, mqtt_port);
  mqtt.setCallback(Callback);
}

void loop()
{
  checkWiFi();

  if (!mqtt.connected())
  {
    conectaMQTT();
  }

  mqtt.loop();

  static unsigned long tempo_pub = 0;
  unsigned long agora = millis();


  if (doc["temperatura"] >= 28.5)
  {
    ledRGB.setPixelColor(0, ledRGB.Color(G, B, R));
    ledRGB.show();
  }else
  {
    ledRGB.setPixelColor(0, ledRGB.Color(0, 0, 0));
    ledRGB.show();
  }
  
  String msg;
  serializeJson(doc, msg);


  // Obter o timestamp atual (em segundos desde 1970)
  time_t rawTime = timeClient.getEpochTime();

  if (agora - tempo_pub > 2000)
  {
    String mensagem;
       serializeJson(doc, mensagem);
    mqtt.publish(mqtt_PUB, mensagem.c_str());
    tempo_pub = agora;
  }

  doc["temperatura"] = dht.readTemperature();
}

void Callback(char *topic, byte *payload, unsigned int length)
{
  String msg((char *)payload, length);
  Serial.printf("Mensagem recebida (topico: [%s]): %s \n\r", topic, msg.c_str());
}

void conectaMQTT()
{
  while (!mqtt.connected())
  {
    Serial.print("Conectando ao AWS IoT Core ...");
    if (mqtt.connect(mqtt_id))
    {
      Serial.println("conectado.");
      mqtt.subscribe(mqtt_SUB);
    }

    else
    {
      Serial.printf("falhou (%d). Tentando Novamente em 5s \n\r", mqtt.state());
      delay(5000);
    }
  }
}

//! Codigo Isaac--------------------------------------------------------------------------------------------

/*
Autor: Isaac Fagundes Morais
Data: 24/06/2025
Nome: LCD de Avicultura
Descrição: Pega informações do MQTT em um Broker AWS 
*/

#include <Arduino.h>
#include <ArduinoJson.h>
#include <PubSubClient.h>
#include <WiFiClientSecure.h>
#include "internet.h"
#include "certificados.h"
#include <LiquidCrystal_I2C.h>

void conectaMqtt(void);
void Callback(char *, byte *, unsigned int);

const int mqtt_port = 8883;

const char *mqtt_id = "Isaac";
const char *mqtt_SUB = "senai134/mesa02";
const char *mqtt_PUB = "senai134/mesa02";

WiFiClientSecure espClient;
PubSubClient mqtt(espClient);
LiquidCrystal_I2C lcd(0x27, 20, 4);
JsonDocument doc;
String msg;
bool porta = 0;
int temperatura = 0;
int distancia;
bool portaAnterior=1;
bool estadoCheio = 0;
bool estadoMedia = 0;
bool estadoBaixo = 0;

void setup()
{
  Serial.begin(9600);
  conectaWiFi();
  espClient.setCACert(AWS_ROOT_CA);
  espClient.setCertificate(AWS_CERT);
  espClient.setPrivateKey(AWS_KEY);
  mqtt.setServer(AWS_BROKER, mqtt_port);
  lcd.init();
  lcd.backlight();
  mqtt.setCallback(Callback);
  lcd.setCursor(7, 0);
  lcd.print ("SENAI");
  lcd.setCursor(0, 1);
  lcd.print("Graus:");
  lcd.setCursor(0, 2);
  lcd.print("Agua:");
  lcd.setCursor(0, 3);
  lcd.print("Portas: Fechado");


}

void loop()
{
  checkWiFi();

  if (!mqtt.connected())
  {
    conectaMqtt();
  }

  mqtt.loop();

  //CODIGO DE PUBLICAÇÃO
  // static unsigned long tempo_pub = 0;
  // unsigned long agora = millis();

  // if (agora - tempo_pub > 2000)
  // {
  //   JsonDocument doc;

  //   doc["msg"] = "Eai compade";

  //   String mensagem;
  //   serializeJson(doc, mensagem);
  //   mqtt.publish(mqtt_PUB, mensagem.c_str());
  //   tempo_pub=agora;
  // }
}
void Callback(char *topic, byte *payload, unsigned int lenght)
{
  String msg((char *)payload, lenght);
  Serial.printf("Menesagem recebida (topico: [%s]): %s \n\r", topic, msg.c_str());

  deserializeJson(doc, msg);

  if (!doc.isNull())
  {
    if (!doc["porta"].isNull())
      porta = doc["porta"];

    if (!doc["temperatura"].isNull())
      temperatura = doc["temperatura"];

    if (!doc["distancia"].isNull())
      distancia = doc["distancia"];
    
    if (temperatura > 9)
    {
      lcd.setCursor(7, 1);
      lcd.printf("%d", temperatura);
    }
    else if (temperatura < 10 && temperatura > 0)
    {
      lcd.setCursor(8, 1);
      lcd.print(" ");
      lcd.setCursor(7, 1);
      lcd.printf("%d ", temperatura);
    }
    // lcd.setCursor(0, 2);
    // lcd.print("            ");
    // lcd.setCursor(0, 2);
    // lcd.print(distancia);

    if (distancia >= 80)
    {
      if (estadoBaixo == 0)
      {
      lcd.setCursor(6, 2);
      lcd.print("            ");
      lcd.setCursor(6, 2);
      lcd.print("Alrt.Baixo");
      estadoBaixo = 1;
      estadoCheio = 0;
      estadoMedia = 0;
    }
    }

   else if (distancia<= 79 && distancia>=40)
    {
       if (estadoMedia == 0)
      {
      lcd.setCursor(6, 2);
      lcd.print("            ");
      lcd.setCursor(6, 2);
      lcd.print("Media");
      estadoBaixo = 0;
      estadoCheio = 0;
      estadoMedia = 1;
      }
      }

   else if (distancia <=39)
    {
       if (estadoCheio == 0)
       {
      lcd.setCursor(6, 2);
      lcd.print("            ");
      lcd.setCursor(6, 2);
      lcd.print("Cheio");
      estadoBaixo = 0;
      estadoCheio = 1;
      estadoMedia = 0;
      }
    }

    if (porta == 1 && !portaAnterior)
    {
      lcd.setCursor(7, 3);
      lcd.print(" Aberta     ");
      portaAnterior = porta;
    }
    else if (!porta && portaAnterior)
    {
      lcd.setCursor(7, 3);
      lcd.print(" Fechada   ");
      portaAnterior = porta;
    }
  }

  }


void conectaMqtt()
{
  while (!mqtt.connected())
  {
    Serial.print("Conectando ao AWS IoT Core.....");

    if (mqtt.connect(mqtt_id))
    {
      Serial.println("CONENCTADO!!!!");
      mqtt.subscribe(mqtt_SUB);
    }

    else
    {
      Serial.printf("Falhou (%d), tentando de novo em 5s", mqtt.state());
      delay(5000);
    }
  }
}

//!Codigo Gabriel------------------------------------------------------------------------------------------------------------------

#include <WiFiClientSecure.h>
#include <Adafruit_NeoPixel.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <Arduino.h>
#include <Bounce2.h>
#include "internet.h"
#include "certificados.h"

#define SERVO_PIN 13
#define LEDC_CHANNEL 0

const int mqtt_port = 8883;
const char *mqtt_id = "idDoEsp32";
const char *mqtt_SUB = "senai134/mesa02";
const char *mqtt_PUB = "senai134/mesa02";
bool cliqueBoot = 0;

Adafruit_NeoPixel ledRGB(1, 48, NEO_GRB); // quantidades de led, pino, tipo
WiFiClientSecure espClient;
PubSubClient mqtt(espClient);
JsonDocument doc;
Bounce btn = Bounce();

void conectaMQTT();
void Callback(char *topic, byte *payload, unsigned int length);
void setServoAngle(int angle);

const int servoPin = 18; // Pino de controle do servo
const int botaoBOOT = 0; // Pino do botão BOOT no ESP32-DevKitM-1

bool alteracaoPorta = true;

void setup()
{
  Serial.begin(9600);
  conectaWiFi();
  pinMode(botaoBOOT, INPUT); // Botão BOOT já tem pul
  ledcSetup(LEDC_CHANNEL, 50, 14);
  ledcAttachPin(SERVO_PIN, LEDC_CHANNEL);
  btn.attach(0, INPUT_PULLUP);

  ledRGB.begin();
  ledRGB.setBrightness(32);

  espClient.setCACert(AWS_ROOT_CA);
  espClient.setCertificate(AWS_CERT);
  espClient.setPrivateKey(AWS_KEY);

  mqtt.setServer(AWS_BROKER, mqtt_port);
  mqtt.setCallback(Callback);
}

void loop()
{
  btn.update();
  checkWiFi();

  if (!mqtt.connected())
  {
    conectaMQTT();
  }

  mqtt.loop();

  static unsigned long tempo_pub = 0;
  unsigned long agora = millis();

  if (btn.fell())
  {
    cliqueBoot = !cliqueBoot;
  }

  if (cliqueBoot)
  {
    static int R = 0;
    static int G = 36;
    static int B = 0;

    setServoAngle(180);
    doc["porta"] = 1;

    ledRGB.setPixelColor(0, ledRGB.Color(R, G, B));
    ledRGB.show();
  }

  else
  {
    static int R = 255;
    static int G = 0;
    static int B = 0;

    setServoAngle(0);
    doc["porta"] = 0;

    ledRGB.setPixelColor(0, ledRGB.Color(R, G, B));
    ledRGB.show();
  }

  if (agora - tempo_pub > 2000)
  {
    String mensagem;
    serializeJson(doc, mensagem);
    mqtt.publish(mqtt_PUB, mensagem.c_str());
    tempo_pub = agora;
  }

}

void Callback(char *topic, byte *payload, unsigned int length)
{
  String msg((char *)payload, length);
  Serial.printf("Mensagem recebida (topico: [%s]): %s\n\r", topic, msg.c_str());

 
}

void conectaMQTT()
{
  while (!mqtt.connected())
  {
    Serial.print("Conectando ao AWS IoT Core ...");
    if (mqtt.connect(mqtt_id))  
    {
      Serial.println("conectado!");
      mqtt.subscribe(mqtt_SUB);
    }
    else
    {
      Serial.printf("falhou (%d). Tentando novamente em 5s \n\r", mqtt.state());
      delay(500);
    }
  }
}

void setServoAngle(int angle)
{
  angle = constrain(angle, 0, 180);
  long pulse_us = map(angle, 0, 180, 500, 2500);

  long period_us = 1000000 / 50;
  long duty_cycle = (pulse_us * ((1 << 14) - 1)) / period_us;

  // Define o ciclo de trabalho para o canal LEDC
  ledcWrite(LEDC_CHANNEL, duty_cycle);
}